程序的常见section及作用
1. .text
存放程序的机器指令(代码)。编译后的程序指令，机器码
不可写

2. .data（已初始化数据段）
存放初始化过的全局变量和静态变量。
可写

3. .bss (未初始化数据段）
存储未初始化的静态局部变量和全局变量。
这个段在程序加载时，会被全部清零。
可写

4. .rodata
存放只读数据，比如字符串字面量/const修饰的全局变量
不可写

5. .heap
程序运行时动态分配的内存(malloc/new)从这里来，向上增长

6. .stack
每个线程的函数调用栈，向下增长，用于存储局部变量，函数调用记录等

高地址
│
│  Stack       ← 函数调用，向下增长
│
│  Heap        ← malloc/new，向上增长
│
│  .bss        ← 未初始化全局/静态变量
│  .data       ← 已初始化全局/静态变量
│  .rodata     ← 字符串、const 数据
│  .text       ← 机器指令
│
低地址


普通局部变量存储在栈上，栈上内存不清零，会保留函数/线程留下的脏数据。
c++规定，全局或静态对象，当且仅当对象首次被用到时，才会进行构造。


程序启动过程:

1. loader的介入
操作系统的Loader加载器负责把可执行文件如elf文件加载到内存中。
加载.text, .data, .bss等段到内存。
建立堆/栈区域。
初始化动态链接器，加载程序依赖的共享库。

2. 进入_start()函数
程序的入口并不是main函数，而是一个叫_start()的函数，由c运行时库提供。
_start()是链接时指定的程序入口点，是程序真正执行的第一条指令。

3. 调用__libc_start_main()
这个函数来自glibc，是C运行时的关键桥梁。
它负责:
调用全局构造函数(c++的global static object构造)
调用main()
main()返回后，再调用exit进行资源管理。

4. 构造函数执行（C++ 关键点）
如果你的程序中有全局对象或静态对象，那么这时候会调用 A() 构造函数 —— 在 main() 之前执行！

5. 执行 main()

6. 析构函数（exit 或 return 后）
如果程序正常退出，__libc_start_main 会在 main 返回后调用所有全局/静态对象的析构函数（对应 .fini_array 段）。

最终调用 exit() 或 _exit() 彻底退出程序。


图示：完整启动过程
用户输入 ./a.out
       │
[操作系统 Loader]
       │
加载 ELF → 加载依赖库 → 初始化堆栈
       │
       ↓
  进入 _start()
       │
       ↓
__libc_start_main(main, ...)
       │
       ├─> 执行构造函数（.init_array）
       │
       └─> 调用 main(argc, argv, envp)
                   ↓
            执行你的代码
                   ↓
               return 或 exit()
       │
       ↓
执行析构函数（.fini_array）
       ↓
程序终止